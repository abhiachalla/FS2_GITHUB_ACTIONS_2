<!DOCTYPE html>
<html lang="en">
<head>
        <title>Documentation</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		</nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		</div>
		<div id="page-nav">
		</div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>

<script type="text/xml" id="search-index-container">
<adrdox>
<listing>
<decl id="1" type="module"><name>packet</name><desc>&lt;div&gt;&lt;span class=&quot;undocumented-note&quot;&gt;Undocumented in source.&lt;/span&gt;&lt;/div&gt;</desc><link>packet.html</link><decl id="2" type="struct"><name>Packet</name><desc>&lt;div&gt;&lt;p&gt;The code defines a C-like struct called Packet which contains various fields such as x, y, r, g, b, msg, type, and size. 
	The x, y, r, g, and b fields are integers and msg is an array of characters with a length of 64. 
	type is also an array of characters, but with a length of 1. Finally, size is an integer that represents the size of the packet.
	The struct also defines a method called GetPacketAsBytes(), which returns a character array that represents the Packet struct in bytes. 
	The method creates a character array called payload with a length of Packet.sizeof, which is the total size of the Packet struct in bytes. 
	The method then uses the memmove function from the string library to copy the values of each field in the Packet struct into the payload array. 
	The memmove function is used to ensure that the values are correctly aligned in memory.
	The method then returns the payload array, which can be used to transmit the Packet struct over a network or store it in a file.&lt;/p&gt;&lt;/div&gt;</desc><link>packet._Packet.html</link></decl></decl><decl id="3" type="module"><name>sdlapp</name><desc>&lt;div&gt;&lt;span class=&quot;undocumented-note&quot;&gt;Undocumented in source.&lt;/span&gt;&lt;/div&gt;</desc><link>sdlapp.html</link><decl id="4" type="class"><name>SDLApp</name><desc>&lt;div&gt;&lt;p&gt;Class SDLApp creates a window and handles user events for mouse and keyboard inputs. 
  It also includes undo and redo functionality.&lt;/p&gt;&lt;/div&gt;</desc><link>sdlapp._S_D_L_App.html</link><decl id="5" type="variable"><name>colorPalette</name><desc>&lt;div&gt;&lt;p&gt;The colorPalette is an array of SDL_Color that contains the default color options for drawing. 
  The defaultBrushSize, defaultRed, defaultGreen, and defaultBlue variables store the default brush size and color options.&lt;/p&gt;&lt;/div&gt;</desc><link>sdlapp._S_D_L_App.color_Palette.html</link></decl><decl id="6" type="function"><name>MainApplicationLoop</name><desc>&lt;div&gt;&lt;p&gt;The MainApplicationLoop function is the main graphics loop that runs until a quit event occurs. 
  Inside the loop, it checks for events using SDL_PollEvent function and handles each event accordingly.&lt;/p&gt;&lt;/div&gt;</desc><link>sdlapp._S_D_L_App._Main_Application_Loop.html</link></decl><decl id="7" type="function"><name>getEraserMode</name><desc>&lt;div&gt;&lt;p&gt;This function takes an integer brushSize as input and returns a boolean value. 
  If the brushSize is -1, it returns true, indicating that the eraser mode is active. 
  Otherwise, it returns false.&lt;/p&gt;&lt;/div&gt;</desc><link>sdlapp._S_D_L_App.get_Eraser_Mode.html</link></decl><decl id="8" type="function"><name>getpacket</name><desc>&lt;div&gt;&lt;p&gt;This function takes various inputs related to drawing, such as the x and y position of the brush, 
  the color of the brush (specified as separate red, green, and blue values), the type of brush 
  (specified as a single character), and the size of the brush (specified as an integer). 
  It then creates a Packet object and sends it over a socket.&lt;/p&gt;&lt;/div&gt;</desc><link>sdlapp._S_D_L_App.getpacket.html</link></decl><decl id="9" type="function"><name>addNewClient</name><desc>&lt;div&gt;&lt;p&gt;This function takes a Socket object as input and sets the class variable 'socket' equal to it.&lt;/p&gt;&lt;/div&gt;</desc><link>sdlapp._S_D_L_App.add_New_Client.html</link></decl><decl id="10" type="function"><name>getcolorRGB</name><desc>&lt;div&gt;&lt;p&gt;This function takes an integer colorIndex as input and returns an SDL_Color object from a colorPalette 
  array at the given index.&lt;/p&gt;&lt;/div&gt;</desc><link>sdlapp._S_D_L_App.getcolor_R_G_B.html</link></decl></decl></decl><decl id="11" type="module"><name>server</name><desc>&lt;div&gt;&lt;span class=&quot;undocumented-note&quot;&gt;Undocumented in source.&lt;/span&gt;&lt;/div&gt;</desc><link>server.html</link><decl id="12" type="class"><name>Server</name><desc>&lt;div&gt;&lt;p&gt;Class Server is the implementation of a server for a multi-client drawing application using sockets&lt;/p&gt;&lt;/div&gt;</desc><link>server._Server.html</link><decl id="13" type="function"><name>start</name><desc>&lt;div&gt;&lt;p&gt;The start() method is the main application loop for the server. It creates a listener socket, 
	binds it to the specified IP and port, and starts listening for client connections. 
	It also creates a readSet that allows for multiplexing of sockets to enable multiple clients to connect to the server. 
	The server waits for clients to connect and adds them to the connectedClientsList. 
	Once a client connects, the server sends them a welcome message, and the client can start sending drawing packets.
	When the server receives a drawing packet from a client, it checks if the message is a quit message or not. 
	If it is a quit message, it removes the client from the connectedClientsList and sends the quit packet to the client. 
	If it is not a quit message, it adds the packet to the packetsSoFar list and broadcasts the packet to all connected 
	clients except the sender.&lt;/p&gt;&lt;/div&gt;</desc><link>server._Server.start.html</link></decl></decl></decl><decl id="14" type="module"><name>client</name><desc>&lt;div&gt;&lt;span class=&quot;undocumented-note&quot;&gt;Undocumented in source.&lt;/span&gt;&lt;/div&gt;</desc><link>client.html</link><decl id="15" type="class"><name>Client</name><desc>&lt;div&gt;&lt;p&gt;Client class represents a client-side network communication program that establishes a connection 
	with a server at a specified IP and port and can be used to send and 
	receive data between the client and server.
	The class Client has three fields: IP, port, and socket. 
	IP and port represent the IP address and port number of the server that the client is connecting to, 
	while socket represents the client's socket object used for communication.
	The this method is a constructor method that takes in IP and port as arguments and initializes the IP and port fields. 
	The constructor also creates a socket object of type Socket with the given IP and port using the AddressFamily.
	INET and SocketType.STREAM options. The connect() method is then called on the socket object to 
	establish a connection with the server at the specified IP and port. If the connection is successful, 
	the method prints &amp;quot;Connected&amp;quot; to the console.&lt;/p&gt;&lt;/div&gt;</desc><link>client._Client.html</link></decl></decl><decl id="16" type="module"><name>surface</name><desc>&lt;div&gt;&lt;span class=&quot;undocumented-note&quot;&gt;Undocumented in source.&lt;/span&gt;&lt;/div&gt;</desc><link>surface.html</link><decl id="17" type="class"><name>Surface</name><desc>&lt;div&gt;&lt;span class=&quot;undocumented-note&quot;&gt;Undocumented in source.&lt;/span&gt;&lt;/div&gt;</desc><link>surface._Surface.html</link><decl id="18" type="function"><name>getBrushSize</name><desc>&lt;div&gt;&lt;p&gt;getBrushSize() funciton returns the brush size as a character ('s' for small, 'm' for medium, or 'l' for large),&lt;/p&gt;&lt;/div&gt;</desc><link>surface._Surface.get_Brush_Size.html</link></decl><decl id="19" type="function"><name>drawColorPalette</name><desc>&lt;div&gt;&lt;p&gt;drawColorPalette() function draws a color palette on the SDL surface&lt;/p&gt;&lt;/div&gt;</desc><link>surface._Surface.draw_Color_Palette.html</link></decl><decl id="20" type="function"><name>drawBrushToolbox</name><desc>&lt;div&gt;&lt;p&gt;drawBrushToolbox() function draws the brush toolbox on the SDL surface.&lt;/p&gt;&lt;/div&gt;</desc><link>surface._Surface.draw_Brush_Toolbox.html</link></decl><decl id="21" type="function"><name>isClickInsideBrushPanel</name><desc>&lt;div&gt;&lt;p&gt;isClickInsideBrushPanel() function takes two integer arguments, x and y, and returns a boolean value indicating 
  whether the specified coordinates are within the bounds of the brush toolbox.&lt;/p&gt;&lt;/div&gt;</desc><link>surface._Surface.is_Click_Inside_Brush_Panel.html</link></decl><decl id="22" type="function"><name>getBrushSizeFromPanel</name><desc>&lt;div&gt;&lt;p&gt;The getBrushSizeFromPanel function takes a Y-coordinate value and calculates the brush size based on the 
  position of the cursor within a brush toolbox panel. The function returns the brush size as an integer value or -1 
  if the cursor is outside the panel.&lt;/p&gt;&lt;/div&gt;</desc><link>surface._Surface.get_Brush_Size_From_Panel.html</link></decl><decl id="23" type="function"><name>getImageSurface</name><desc>&lt;div&gt;&lt;p&gt;The getImageSurface function returns a pointer to an SDL_Surface object, which represents an image surface.&lt;/p&gt;&lt;/div&gt;</desc><link>surface._Surface.get_Image_Surface.html</link></decl><decl id="24" type="function"><name>changePixel</name><desc>&lt;div&gt;&lt;p&gt;The changePixel function is used to change the color of a pixel at a given coordinate (x, y) on the image surface. 
The function takes the RGB values of the new color as well as the brush type and size. 
  Depending on the brush type, the function modifies several pixels around the target pixel to create the effect 
  of a brush stroke. The function uses SDL_LockSurface and SDL_UnlockSurface functions to access the pixel 
  data of the image surface safely.&lt;/p&gt;&lt;/div&gt;</desc><link>surface._Surface.change_Pixel.html</link></decl><decl id="25" type="function"><name>PixelAt</name><desc>&lt;div&gt;&lt;p&gt;The PixelAt function returns the color of the pixel at the given coordinate (x, y) on the image surface. 
  The function uses SDL_LockSurface and SDL_UnlockSurface functions to access the pixel data of the image 
  surface safely. It returns an SDL_Color object containing the RGB and alpha values of the pixel.&lt;/p&gt;&lt;/div&gt;</desc><link>surface._Surface._Pixel_At.html</link></decl><decl id="26" type="function"><name>loadTexture</name><desc>&lt;div&gt;&lt;p&gt;The loadTexture function loads an image file from the given mediaPath and creates an SDL_Texture object 
  from the loaded surface using the given renderer. It returns the created texture object or null if there was an error
   loading or creating the texture.&lt;/p&gt;&lt;/div&gt;</desc><link>surface._Surface.load_Texture.html</link></decl></decl></decl><decl id="27" type="module"><name>serverdata</name><desc>&lt;div&gt;&lt;span class=&quot;undocumented-note&quot;&gt;Undocumented in source.&lt;/span&gt;&lt;/div&gt;</desc><link>serverdata.html</link><decl id="28" type="function"><name>fetchDataFromServer</name><desc>&lt;div&gt;&lt;p&gt;fetchDataFromServer that takes two shared variables, a Socket and a Surface. 
	The purpose of this function is to fetch data from the server using the Socket and update the Surface accordingly.
	The function uses a while loop to keep fetching data from the server as long as the connection is active. 
	Inside the loop, it first creates a buffer of bytes with a size equal to the Packet.
	sizeof constant (presumably the size of the packet being sent/received). 
	It then receives data from the server using the socket.receive method and stores it in the buffer. 
	The received data is then parsed to extract various fields such as the x and y coordinates, the RGB values, 
	the packet type, and the message.
	Next, the parsed values are used to create a Packet object, which is a custom-defined struct with 
	fields corresponding to the extracted fields. The function then checks the message type and, if it is 'u', 
	it iterates through a nested loop to update the pixels on the Surface with the provided RGB values, brush size, 
	and type. If the message type is 'q', it sets the isConnectionActive flag to false to exit the loop and 
	terminate the connection.
	Overall, this function fetches packets of data from a server, parses and extracts the relevant fields from the packet, 
	and updates the Surface accordingly.&lt;/p&gt;&lt;/div&gt;</desc><link>serverdata.fetch_Data_From_Server.html</link></decl></decl><decl id="29" type="module"><name>app</name><desc>&lt;div&gt;&lt;span class=&quot;undocumented-note&quot;&gt;Undocumented in source.&lt;/span&gt;&lt;/div&gt;</desc><link>app.html</link><decl id="30" type="function"><name>main</name><desc>&lt;div&gt;&lt;p&gt;The problem statement of the project is to create a painting application that enables 
	at least three users to connect to a server application and collaborate on a single painting in real-time. 
	The server will broadcast changes to each user as they paint, ensuring that all users are working on the 
	same version of the painting. 
	This project will address the need for a collaborative painting application that allows users to work together 
	on a single canvas in real-time, enhancing creativity and collaboration among users.&lt;/p&gt;&lt;/div&gt;</desc><link>app.main.html</link></decl></decl></listing>
<index>
</index>
</adrdox>
</script>
<script src="search-docs.js"></script>
</body></html>
